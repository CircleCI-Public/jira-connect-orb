version: 2.1

description: Reports job status back to Atlassian JIRA instance using Atlassian Connect. 
  Must install [Ap NAME] from Atlassian Marketplace, and provide the proper ENV VARs.
  SharedSecret must be exposed as ATLASSIAN_CONNECT_SECRET



examples:
  basic_workflow:
    description: Notify Atlassian for each job.
    usage:
      version: 2.1
      orbs: 
        jira: circleci/jira@volatile

      workflows:
        build:
          jobs:
            - build:
                post-steps:
                  - jira/notify

      jobs:
        build:
          docker:
          - image: circleci/node:10
          steps:
            - run: echo "hello"

commands:
  notify:
    parameters:
      base_url:
        description: The base Url for your Atlassian Jira Cloud instance. If omitted the env. variable ${JIRA_BASE_URL} is used.
        default: "${JIRA_BASE_URL}"
        type: string
      token_name:
        description: The name of environment variable containing CircleCI API. Only required if private project
        default: ""
        type: string
      job_type:
        description: Indicates if job should be treated as build or deployment in Jira dev panel. Note that Deployments require additional details
        default: "build"
        type: enum
        enum: ["build", "deployment"]
      environment:
        description: For deployments. Indicates the name of target environment
        default: "Dev1"
        type: string
      environment_type:
        description: Indicates the category of target environment as defined by Atlassian
        type: enum
        enum: ["production", "staging", "testing", "development", "unmapped"]
        default: "development"
    steps:
      - run:
          name: JIRA - Setting Failure Condition
          command: |
            echo 'export JIRA_BUILD_STATUS="failed"' >> $BASH_ENV
          when: on_fail

      - run:
          name: JIRA - Setting Success Condition
          command: |
            echo 'export JIRA_BUILD_STATUS="successful"' >> $BASH_ENV
          when: on_success

      - run: 
          when: always
          name: Update status in Atlassian Jira
          command: |
            base_url="<<parameters.base_url>>"
            cannonical="/rest/<<parameters.job_type>>s/0.1/bulk"
            app_key="circleci.jira.buildsbeta"
            secret="${ATLASSIAN_CONNECT_SECRET}"

            run () {
              parse_jira_key_array
              if [ "x" != "x${ISSUE_KEYS}" ]; then
                generate_json_payload_<<parameters.job_type>>
                generate_jwt_token
                post_to_jira
              else
                echo "No Jira issue keys found in changelog"
              fi
            }

            parse_jira_key_array () {
              # must save as ISSUE_KEYS='["CC-4"]'
              if [[ $(echo $CIRCLE_REPOSITORY_URL | grep github.com) ]]; then
                VCS_TYPE=github
              else
                VCS_TYPE=bitbucket
              fi
              echo "Attempt to get Jira Issues from  https://circleci.com/api/v1.1/project/$VCS_TYPE/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_BUILD_NUM"
              curl -s <<# parameters.token_name >> --user "${<<parameters.token_name>>}:" <</parameters.token_name>> \
              -o /tmp/job_info.json \
              https://circleci.com/api/v1.1/project/$VCS_TYPE/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_BUILD_NUM
              # see https://jqplay.org/s/TNq7c5ctot
              ISSUE_KEYS=$(cat /tmp/job_info.json | jq '[.all_commit_details[].subject | scan("([A-Z]{2,30}-[0-9]+)")   | .[] ]')
            }

            generate_json_payload_build () {
              iso_time=$(date '+%Y-%m-%dT%T%z'| sed -e 's/\([0-9][0-9]\)$/:\1/g')
              echo {} | jq \
              --arg time_str "$(date +%s)" \
              --arg lastUpdated "${iso_time}" \
              --arg state "${JIRA_BUILD_STATUS}" \
              --arg jobName "${CIRCLE_JOB}" \
              --arg buildNumber "${CIRCLE_BUILD_NUM}" \
              --arg url "${CIRCLE_BUILD_URL}" \
              --arg workflowUrl "https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}" \
              --arg commit "${CIRCLE_SHA1}" \
              --arg refUri "${CIRCLE_REPOSITORY_URL}/tree/${CIRCLE_BRANCH}" \
              --arg repositoryUri "${CIRCLE_REPOSITORY_URL}" \
              --arg branchName "${CIRCLE_BRANCH}" \
              --arg workflowId "${CIRCLE_WORKFLOW_ID}" \
              --arg repoName "${CIRCLE_PROJECT_REPONAME}" \
              --arg display "#${CIRCLE_BUILD_NUM} ${CIRCLE_PROJECT_REPONAME} - ${CIRCLE_JOB}"  \
              --arg description "${CIRCLE_PROJECT_REPONAME} #${CIRCLE_BUILD_NUM} ${CIRCLE_JOB}" \
              --argjson issueKeys "${ISSUE_KEYS}" \
              '
              ($time_str | tonumber) as $time_num |
              {
                "builds": [
                  {
                    "schemaVersion": "1.0",
                    "pipelineId": $workflowId,
                    "buildNumber": $buildNumber,
                    "updateSequenceNumber": 1,
                    "displayName": $display,
                    "description": $description,
                    "url": $workflowUrl,
                    "state": $state, 
                    "lastUpdated": $lastUpdated,
                    "issueKeys": $issueKeys
                  }
                ]
              }
              ' > /tmp/jira-status.json
            }


            generate_json_payload_deployment () {
              iso_time=$(date '+%Y-%m-%dT%T%z'| sed -e 's/\([0-9][0-9]\)$/:\1/g')
              echo {} | jq \
              --arg time_str "$(date +%s)" \
              --arg lastUpdated "${iso_time}" \
              --arg state "${JIRA_BUILD_STATUS}" \
              --arg jobName "${CIRCLE_JOB}" \
              --arg buildNumber "${CIRCLE_BUILD_NUM}" \
              --arg url "${CIRCLE_BUILD_URL}" \
              --arg commit "${CIRCLE_SHA1}" \
              --arg refUri "${CIRCLE_REPOSITORY_URL}/tree/${CIRCLE_BRANCH}" \
              --arg repositoryUri "${CIRCLE_REPOSITORY_URL}" \
              --arg branchName "${CIRCLE_BRANCH}" \
              --arg workflowId "${CIRCLE_WORKFLOW_ID}" \
              --arg workflowUrl "https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}" \
              --arg repoName "${CIRCLE_PROJECT_REPONAME}" \
              --arg pipelineDisplay "#${CIRCLE_BUILD_NUM} ${CIRCLE_PROJECT_REPONAME} - ${CIRCLE_JOB}"  \
              --arg deployDisplay "#${CIRCLE_BUILD_NUM}  ${CIRCLE_PROJECT_REPONAME} - <<parameters.environment>>"  \
              --arg description "${CIRCLE_PROJECT_REPONAME} #${CIRCLE_BUILD_NUM} ${CIRCLE_JOB} <<parameters.environment>>" \
              --arg envId "${CIRCLE_WORKFLOW_ID}-<<parameters.environment>>" \
              --arg envName "<<parameters.environment>>" \
              --arg envType "<<parameters.environment_type>>" \
              --argjson issueKeys "${ISSUE_KEYS}" \
              '
              ($time_str | tonumber) as $time_num |
              {
                "deployments": [
                  {
                    "schemaVersion": "1.0",
                    "pipeline": {
                      "id": $workflowId,
                      "displayName": $pipelineDisplay,
                      "url": $workflowUrl
                    },
                    "deploymentSequenceNumber": $buildNumber,
                    "updateSequenceNumber": 1,
                    "displayName": $deployDisplay,
                    "description": $description,
                    "url": $url,
                    "state": $state, 
                    "lastUpdated": $lastUpdated,
                    "issueKeys": $issueKeys,
                    "environment":{
                      "id": $envId,
                      "displayName": $envName,
                      "type": $envType
                    }
                  }
                ]
              }
              ' > /tmp/jira-status.json
            }

            generate_jwt_token () {
              generate_query_string_hash
              header='{
                "typ": "JWT",
                "alg": "HS256"
              }'
              claims=$(
                echo "{}" | jq --arg time_str "$(date +%s)" --arg qsh "$qsh" --arg iss "$app_key" \
                '
                ($time_str | tonumber) as $time_num
                | .iat=($time_num - 600)
                | .exp=($time_num + 600)
                | .qsh=$qsh
                | .iss=$iss
                '
              )
              header_base64=$(echo "${header}" | json | base64_encode)
              claims_base64=$(echo "${claims}" | json | base64_encode)

              signing_input=$(echo "${header_base64}.${claims_base64}")
              signature=$(echo "${signing_input}" | hmacsha256_sign | base64_encode)
              jwt_token="${signing_input}.${signature}"

            }

            
            post_to_jira () {
              echo "Associating build with $ISSUE_KEYS on ${base_url}"
              HTTP_STATUS=$(curl -s -w "%{http_code}" -o /tmp/curl_response.txt \
              -H "Authorization: JWT ${jwt_token}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -X POST "${base_url}${cannonical}" --data @/tmp/jira-status.json)

              cat /tmp/curl_response.txt

              if [ "${HTTP_STATUS}" != "202" ];then 
                echo "Error calling Jira, result: ${HTTP_STATUS}"
                exit 1
              else
                echo "Success!"
              fi
            }

            generate_query_string_hash () {
              query_string="POST&${cannonical}&"
              # Use jq to set the dynamic `qsh`, `iat` and `exp`
              # fields on the header using the current time.
              # For more on "qsh" see https://developer.atlassian.com/cloud/jira/platform/understanding-jwt/#a-name-qsh-a-creating-a-query-string-hash
              qsh=$(printf %s "$query_string" | openssl dgst -sha256 | cut -d" " -f2)   
            }


            base64_encode()
            {
              declare input=${1:-$(</dev/stdin)}
              # Use `tr` to URL encode the output from base64.
              printf '%s' "${input}" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'
            }

            json() {
              declare input=${1:-$(</dev/stdin)}
              printf '%s' "${input}" | jq -c .
            }

            hmacsha256_sign()
            {
              declare input=${1:-$(</dev/stdin)}
              printf '%s' "${input}" | openssl dgst -binary -sha256 -hmac "${secret}"
            }


            run 


